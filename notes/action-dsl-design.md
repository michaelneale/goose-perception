# Action DSL Design

Simple text-based DSL for macOS automation that LLM can output.

## Status: IMPLEMENTED

Files created:
- `Services/Actions/ActionCommand.swift` - Enum of all commands
- `Services/Actions/ActionDSLParser.swift` - Parses LLM text â†’ commands  
- `Services/Actions/ActionExecutor.swift` - Executes commands on macOS
- `Services/Actions/ActionService.swift` - Orchestrates: context â†’ LLM â†’ parse â†’ execute
- `Views/AutomationResultSheet.swift` - Debug UI showing full trace

UI integration:
- "Automate" button (wand icon) on each action in Actions tab
- Opens sheet showing: Context, System Prompt, User Prompt, LLM Response, Parsed Commands, Execution Results

---

## Concept

```
User trigger (popup action, scheduled, etc.)
    â†“
Build prompt with context + available actions
    â†“
LLM outputs action commands as plain text
    â†“
Parse commands â†’ Execute on macOS
    â†“
Report results back to user
```

**Key principle**: LLM outputs structured text commands, not code. We parse and execute safely.

---

## DSL Syntax

Simple line-based format. Each line is one command:

```
COMMAND arg1 "arg2 with spaces" arg3
```

### File Operations

```
MOVE_FILE "/path/from" "/path/to"
COPY_FILE "/path/from" "/path/to"
DELETE_FILE "/path/to/file"
CREATE_FOLDER "/path/to/folder"
OPEN_FILE "/path/to/file"                    # Opens with default app
OPEN_FILE "/path/to/file" "App Name"         # Opens with specific app
REVEAL_IN_FINDER "/path/to/file"
```

### Document Creation

```
WRITE_FILE "/path/to/file.txt" "content here"
APPEND_FILE "/path/to/file.txt" "additional content"
WRITE_DOC "/path/to/doc.md" <<END
# Markdown content
Multiple lines supported
END
```

### Communication

```
SEND_EMAIL "recipient@example.com" "Subject" "Body text"
SEND_EMAIL "recipient@example.com" "Subject" <<END
Multi-line
email body
END
OPEN_URL "https://example.com"
COPY_TO_CLIPBOARD "text to copy"
```

### App Control

```
OPEN_APP "App Name"
QUIT_APP "App Name"
ACTIVATE_APP "App Name"                      # Bring to front
```

### Notifications

```
NOTIFY "Title" "Message"
NOTIFY "Title" "Message" "sound_name"
```

### System

```
SPEAK "Text to speak"
SET_VOLUME 50                                # 0-100
DO_NOT_DISTURB ON|OFF
```

### Shortcuts Integration

```
RUN_SHORTCUT "Shortcut Name"
RUN_SHORTCUT "Shortcut Name" "input text"
```

### Calendar (future)

```
CREATE_EVENT "Title" "2024-01-28 14:00" "2024-01-28 15:00"
CREATE_REMINDER "Task description" "2024-01-28 14:00"
```

---

## Example LLM Output

Given context about user working late with pending TODOs:

```
NOTIFY "Time to wrap up" "You have 3 pending tasks - consider finishing tomorrow"
WRITE_DOC "~/Documents/tomorrow-tasks.md" <<END
# Tasks for Tomorrow

From your work session on Jan 28:

1. Review PR for perception2
2. Finish action DSL implementation  
3. Update documentation

---
Generated by GoosePerception
END
OPEN_FILE "~/Documents/tomorrow-tasks.md"
```

---

## Implementation

### 1. ActionDSL Parser

```swift
// Services/Actions/ActionDSLParser.swift

enum ActionCommand {
    case moveFile(from: String, to: String)
    case copyFile(from: String, to: String)
    case deleteFile(path: String)
    case createFolder(path: String)
    case openFile(path: String, app: String?)
    case revealInFinder(path: String)
    
    case writeFile(path: String, content: String)
    case appendFile(path: String, content: String)
    
    case sendEmail(to: String, subject: String, body: String)
    case openURL(url: String)
    case copyToClipboard(text: String)
    
    case openApp(name: String)
    case quitApp(name: String)
    case activateApp(name: String)
    
    case notify(title: String, message: String, sound: String?)
    case speak(text: String)
    
    case runShortcut(name: String, input: String?)
    
    case unknown(line: String)
}

struct ActionDSLParser {
    func parse(_ text: String) -> [ActionCommand] {
        var commands: [ActionCommand] = []
        var lines = text.components(separatedBy: .newlines)
        var i = 0
        
        while i < lines.count {
            let line = lines[i].trimmingCharacters(in: .whitespaces)
            if line.isEmpty || line.hasPrefix("#") {
                i += 1
                continue
            }
            
            // Handle heredoc syntax
            if line.contains("<<END") {
                var content = ""
                i += 1
                while i < lines.count && lines[i] != "END" {
                    content += lines[i] + "\n"
                    i += 1
                }
                // Parse command with heredoc content
                commands.append(parseLineWithHeredoc(line, content: content))
            } else {
                commands.append(parseLine(line))
            }
            i += 1
        }
        
        return commands
    }
    
    private func parseLine(_ line: String) -> ActionCommand {
        let tokens = tokenize(line)
        guard let command = tokens.first?.uppercased() else {
            return .unknown(line: line)
        }
        
        switch command {
        case "MOVE_FILE":
            guard tokens.count >= 3 else { return .unknown(line: line) }
            return .moveFile(from: tokens[1], to: tokens[2])
        case "COPY_FILE":
            guard tokens.count >= 3 else { return .unknown(line: line) }
            return .copyFile(from: tokens[1], to: tokens[2])
        case "NOTIFY":
            guard tokens.count >= 3 else { return .unknown(line: line) }
            return .notify(title: tokens[1], message: tokens[2], sound: tokens.count > 3 ? tokens[3] : nil)
        // ... etc
        default:
            return .unknown(line: line)
        }
    }
    
    private func tokenize(_ line: String) -> [String] {
        // Handle quoted strings and spaces
        var tokens: [String] = []
        var current = ""
        var inQuotes = false
        
        for char in line {
            if char == "\"" {
                inQuotes.toggle()
            } else if char == " " && !inQuotes {
                if !current.isEmpty {
                    tokens.append(current)
                    current = ""
                }
            } else {
                current.append(char)
            }
        }
        if !current.isEmpty {
            tokens.append(current)
        }
        
        return tokens
    }
}
```

### 2. ActionExecutor

```swift
// Services/Actions/ActionExecutor.swift

actor ActionExecutor {
    
    struct ExecutionResult {
        let command: ActionCommand
        let success: Bool
        let message: String?
        let error: String?
    }
    
    func execute(_ commands: [ActionCommand]) async -> [ExecutionResult] {
        var results: [ExecutionResult] = []
        
        for command in commands {
            let result = await executeOne(command)
            results.append(result)
            
            // Stop on first error? Or continue?
            // if !result.success { break }
        }
        
        return results
    }
    
    private func executeOne(_ command: ActionCommand) async -> ExecutionResult {
        do {
            switch command {
            case .moveFile(let from, let to):
                try FileManager.default.moveItem(atPath: expand(from), toPath: expand(to))
                return .init(command: command, success: true, message: "Moved file", error: nil)
                
            case .copyFile(let from, let to):
                try FileManager.default.copyItem(atPath: expand(from), toPath: expand(to))
                return .init(command: command, success: true, message: "Copied file", error: nil)
                
            case .deleteFile(let path):
                try FileManager.default.removeItem(atPath: expand(path))
                return .init(command: command, success: true, message: "Deleted file", error: nil)
                
            case .createFolder(let path):
                try FileManager.default.createDirectory(atPath: expand(path), withIntermediateDirectories: true)
                return .init(command: command, success: true, message: "Created folder", error: nil)
                
            case .openFile(let path, let app):
                let url = URL(fileURLWithPath: expand(path))
                if let app = app {
                    NSWorkspace.shared.open([url], withApplicationAt: URL(fileURLWithPath: "/Applications/\(app).app"), configuration: .init())
                } else {
                    NSWorkspace.shared.open(url)
                }
                return .init(command: command, success: true, message: "Opened file", error: nil)
                
            case .revealInFinder(let path):
                NSWorkspace.shared.selectFile(expand(path), inFileViewerRootedAtPath: "")
                return .init(command: command, success: true, message: "Revealed in Finder", error: nil)
                
            case .writeFile(let path, let content):
                try content.write(toFile: expand(path), atomically: true, encoding: .utf8)
                return .init(command: command, success: true, message: "Wrote file", error: nil)
                
            case .appendFile(let path, let content):
                let handle = try FileHandle(forWritingTo: URL(fileURLWithPath: expand(path)))
                handle.seekToEndOfFile()
                handle.write(content.data(using: .utf8)!)
                handle.closeFile()
                return .init(command: command, success: true, message: "Appended to file", error: nil)
                
            case .sendEmail(let to, let subject, let body):
                let service = NSSharingService(named: .composeEmail)!
                service.recipients = [to]
                service.subject = subject
                await MainActor.run {
                    service.perform(withItems: [body])
                }
                return .init(command: command, success: true, message: "Opened email compose", error: nil)
                
            case .openURL(let url):
                if let url = URL(string: url) {
                    NSWorkspace.shared.open(url)
                }
                return .init(command: command, success: true, message: "Opened URL", error: nil)
                
            case .copyToClipboard(let text):
                NSPasteboard.general.clearContents()
                NSPasteboard.general.setString(text, forType: .string)
                return .init(command: command, success: true, message: "Copied to clipboard", error: nil)
                
            case .openApp(let name):
                NSWorkspace.shared.launchApplication(name)
                return .init(command: command, success: true, message: "Opened \(name)", error: nil)
                
            case .quitApp(let name):
                let apps = NSWorkspace.shared.runningApplications.filter { $0.localizedName == name }
                for app in apps { app.terminate() }
                return .init(command: command, success: true, message: "Quit \(name)", error: nil)
                
            case .activateApp(let name):
                let apps = NSWorkspace.shared.runningApplications.filter { $0.localizedName == name }
                apps.first?.activate()
                return .init(command: command, success: true, message: "Activated \(name)", error: nil)
                
            case .notify(let title, let message, let sound):
                await showNotification(title: title, message: message, sound: sound)
                return .init(command: command, success: true, message: "Showed notification", error: nil)
                
            case .speak(let text):
                let synth = NSSpeechSynthesizer()
                synth.startSpeaking(text)
                return .init(command: command, success: true, message: "Speaking", error: nil)
                
            case .runShortcut(let name, let input):
                try await runShortcut(name: name, input: input)
                return .init(command: command, success: true, message: "Ran shortcut", error: nil)
                
            case .unknown(let line):
                return .init(command: command, success: false, message: nil, error: "Unknown command: \(line)")
            }
        } catch {
            return .init(command: command, success: false, message: nil, error: error.localizedDescription)
        }
    }
    
    private func expand(_ path: String) -> String {
        NSString(string: path).expandingTildeInPath
    }
    
    private func showNotification(title: String, message: String, sound: String?) async {
        let content = UNMutableNotificationContent()
        content.title = title
        content.body = message
        if let sound = sound {
            content.sound = UNNotificationSound(named: UNNotificationSoundName(sound))
        }
        let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: nil)
        try? await UNUserNotificationCenter.current().add(request)
    }
    
    private func runShortcut(name: String, input: String?) async throws {
        var args = ["shortcuts", "run", name]
        if let input = input {
            args += ["-i", input]
        }
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
        process.arguments = args
        try process.run()
        process.waitUntilExit()
    }
}
```

### 3. ActionPromptBuilder

Build prompts that include available actions:

```swift
// Services/Actions/ActionPromptBuilder.swift

struct ActionPromptBuilder {
    let context: ActionContext  // From generators
    
    func buildPrompt(for trigger: ActionTrigger) -> String {
        """
        You are a helpful assistant that can execute actions on macOS.
        
        AVAILABLE ACTIONS:
        - MOVE_FILE "from" "to" - Move a file
        - COPY_FILE "from" "to" - Copy a file
        - DELETE_FILE "path" - Delete a file
        - CREATE_FOLDER "path" - Create a folder
        - OPEN_FILE "path" - Open a file
        - OPEN_FILE "path" "App Name" - Open with specific app
        - REVEAL_IN_FINDER "path" - Show in Finder
        - WRITE_FILE "path" "content" - Write text to file
        - WRITE_DOC "path" <<END ... END - Write multi-line document
        - SEND_EMAIL "to" "subject" "body" - Compose email
        - OPEN_URL "url" - Open URL in browser
        - COPY_TO_CLIPBOARD "text" - Copy to clipboard
        - OPEN_APP "name" - Open application
        - NOTIFY "title" "message" - Show notification
        - SPEAK "text" - Speak text aloud
        - RUN_SHORTCUT "name" - Run a Shortcuts automation
        
        CONTEXT:
        Current time: \(Date())
        User mood: \(context.currentMood ?? "unknown")
        Work duration: \(context.workDurationMinutes) minutes
        Recent projects: \(context.recentProjects.joined(separator: ", "))
        Pending tasks: \(context.pendingTodos.map { $0.description }.joined(separator: "; "))
        
        TRIGGER: \(trigger.description)
        
        Respond with ONLY the action commands to execute, one per line.
        Use # for comments. Be concise.
        If no action is needed, respond with: # No action needed
        """
    }
}
```

### 4. Integration with Action Generators

```swift
// Update ActionGenerators to optionally request DSL execution

struct AutomatedActionGenerator: ActionGenerator {
    let name = "Automated"
    let cooldownMinutes: Double = 30
    
    func shouldTrigger(context: ActionContext) -> Bool {
        // Trigger when we have accumulated insights that suggest automation
        // e.g., "User mentioned wanting to organize files"
        context.insights.contains { $0.content.lowercased().contains("organize") }
    }
    
    func generate(context: ActionContext) -> Action? {
        // Instead of just creating a popup, we could:
        // 1. Call LLM with ActionPromptBuilder
        // 2. Parse response with ActionDSLParser
        // 3. Execute with ActionExecutor
        // 4. Return action summarizing what was done
        
        return Action(
            type: "automation",
            title: "Automated Action",
            message: "Organizing your recent downloads...",
            source: name,
            priority: 3
        )
    }
}
```

---

## Safety Considerations

### 1. Sandboxing
- Only allow operations in user directories (~/Documents, ~/Downloads, ~/Desktop)
- Whitelist allowed apps for OPEN_APP/QUIT_APP
- Require confirmation for DELETE_FILE

### 2. Confirmation Modes
```swift
enum ConfirmationMode {
    case always      // Always ask before executing
    case destructive // Only ask for delete/move operations
    case never       // Auto-execute (dangerous!)
}
```

### 3. Dry Run
```swift
func execute(_ commands: [ActionCommand], dryRun: Bool = false) async -> [ExecutionResult]
```

### 4. Audit Log
Store all executed commands in database for review.

---

## UI Integration

### Automation Tab in Dashboard
- Show recent automated actions
- Toggle automation on/off
- Set confirmation mode
- View/edit allowed actions whitelist

### Action Preview Popup
When LLM suggests actions, show preview:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¤– Suggested Actions                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Create folder ~/Documents/Project-X  â”‚
â”‚ 2. Move 3 files to new folder           â”‚
â”‚ 3. Open folder in Finder                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [Cancel]  [Edit]  [Execute]             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## File Structure

```
Services/Actions/
â”œâ”€â”€ ActionDSLParser.swift      # Parse LLM output â†’ commands
â”œâ”€â”€ ActionExecutor.swift       # Execute commands on macOS
â”œâ”€â”€ ActionPromptBuilder.swift  # Build prompts with available actions
â”œâ”€â”€ ActionCommand.swift        # Command enum and types
â””â”€â”€ ActionSafety.swift         # Sandboxing, confirmation, audit
```

---

## Implementation Order

1. **ActionCommand enum** - Define all supported commands
2. **ActionDSLParser** - Parse text to commands
3. **ActionExecutor** - Execute commands (start with safe ones: NOTIFY, OPEN_URL, COPY_TO_CLIPBOARD)
4. **ActionPromptBuilder** - Build prompts for LLM
5. **Integration** - Wire into action generators
6. **UI** - Preview/confirmation popup
7. **Safety** - Sandboxing and audit logging
