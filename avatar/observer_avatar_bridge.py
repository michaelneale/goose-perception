#!/usr/bin/env python3
"""
observer_avatar_bridge.py - Bridge between observer system and avatar display
Monitors observer outputs and triggers appropriate avatar messages
"""

import os
import sys
import time
import random
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
import threading
import hashlib
import pickle
import json

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from emotion_context import emotion_context
    from message_queue import message_queue
    EMOTION_FEATURES_AVAILABLE = True
except ImportError:
    EMOTION_FEATURES_AVAILABLE = False
    print("Emotion-aware features not available - running in basic mode")

try:
    from . import avatar_display
except ImportError:
    avatar_display = None

class ObserverAvatarBridge:
    def __init__(self):
        self.base_dir = Path(__file__).parent.parent
        self.perception_dir = Path.home() / ".local/share/goose-perception" 
        self.perception_dir.mkdir(parents=True, exist_ok=True)
        self.state_dir = Path.home() / ".local/share/goose-perception" 
        self.state_dir.mkdir(parents=True, exist_ok=True)
        
        # Emotion-aware message queue
        from message_queue import EmotionAwareMessageQueue
        self.emotion_aware_messages = EmotionAwareMessageQueue()
        
        # Initialize previous emotional state tracking
        self.previous_emotion_state = None
        
        # File monitoring
        self.file_watcher = None
        self.monitoring = False
        self.file_last_modified = {}
        
        # Load state first, then initialize queues
        self._load_state()
        
        # Suggestion queues and state
        self.suggestion_queue = getattr(self, 'suggestion_queue', [])
        self.shown_suggestions = getattr(self, 'shown_suggestions', set())
        self.last_suggestion_display = getattr(self, 'last_suggestion_display', datetime.min)
        
        # Actionable suggestion queue and state  
        self.actionable_suggestion_queue = getattr(self, 'actionable_suggestion_queue', [])
        self.shown_actionable_suggestions = getattr(self, 'shown_actionable_suggestions', set())
        self.last_actionable_display = getattr(self, 'last_actionable_display', datetime.min)
        
        # Chitchat queue and state
        self.chitchat_queue = getattr(self, 'chitchat_queue', [])
        self.shown_chitchat = getattr(self, 'shown_chitchat', set())
        self.last_chitchat_display = getattr(self, 'last_chitchat_display', datetime.min)
        
        # Feedback tracking
        self.completed_suggestions = getattr(self, 'completed_suggestions', set())
        self.dismissed_suggestions = getattr(self, 'dismissed_suggestions', set())
        
        # Set up emotion context monitoring
        try:
            import sys
            import os
            parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            if parent_dir not in sys.path:
                sys.path.append(parent_dir)
            from emotion_context import emotion_context
            self.emotion_context = emotion_context
            # Initialize previous state
            self.previous_emotion_state = self._get_emotion_state_snapshot()
        except Exception as e:
            print(f"⚠️ Could not initialize emotion context: {e}")
            self.emotion_context = None
            self.previous_emotion_state = None
        self.last_check_times = {}
        self.last_file_contents = {}
        self.is_running = False
        self.last_suggestions_run = datetime.min
        self.suggestions_interval = timedelta(minutes=10)  # Run avatar suggestions every 10 minutes (more frequent)
        self.last_idle_chatter = datetime.min
        self.idle_chatter_interval = timedelta(minutes=12)  # Show idle chatter every 12 minutes (less frequent)
        self.last_suggestion_show = datetime.min
        self.suggestion_show_interval = timedelta(minutes=15)  # Show existing suggestions every 15 minutes (less frequent)
        
        # Dedicated actionable suggestions timing
        self.last_actionable_show = datetime.min
        self.actionable_show_interval = timedelta(minutes=8)  # Show actionable suggestions every 8 minutes
        self.actionable_suggestions_chance = 0.7  # 70% chance to show actionable suggestions when due
        
        # Ensure perception directory exists
        self.perception_dir.mkdir(parents=True, exist_ok=True)
        
        # Files to monitor
        self.monitored_files = {
            'WORK.md': 'work',
            'LATEST_WORK.md': 'work',
            'INTERACTIONS.md': 'interaction',
            'CONTRIBUTIONS.md': 'productivity',
            'ACTIVITY-LOG.md': 'general',
            'AVATAR_SUGGESTIONS.json': 'suggestions',
            'ACTIONABLE_SUGGESTIONS.json': 'actionable'
        }
        
        # Chit-chat will now be generated by recipe instead of hardcoded
        self.chatter_interval = timedelta(minutes=12)  # Generate new chatter every 12 minutes
        self.last_chatter_run = datetime.now() - self.chatter_interval
        
        # Track shown actionable suggestions to cycle through them
        self.shown_actionable_suggestions = []
        self.max_remembered_actionable = 6  # Remember last 6 shown to avoid immediate repeats
        
        self.suggestion_queue = []  # Queue for pending suggestions
        self.shown_suggestions = set()  # Hashes of shown suggestions
        self.last_suggestion_display = datetime.min  # Last time a suggestion was shown
        self.min_suggestion_interval = timedelta(minutes=3)  # Minimum 3 minutes between suggestions

        self.actionable_suggestion_queue = []
        self.shown_actionable_suggestions = set()
        self.last_actionable_display = datetime.min
        self.min_actionable_interval = timedelta(minutes=3)

        self.chitchat_queue = []
        self.shown_chitchat = set()
        self.last_chitchat_display = datetime.min
        self.min_chitchat_interval = timedelta(minutes=3)

        self.completed_suggestions = set()
        self.dismissed_suggestions = set()

        self.state_dir = Path.home() / ".local/share/goose-perception/avatar_state"
        self.state_dir.mkdir(parents=True, exist_ok=True)
        self._load_state()
    
    def start_monitoring(self):
        """Start monitoring observer files"""
        if avatar_display is None:
            print("Avatar display not available, bridge disabled")
            return
            
        self.is_running = True
        monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        monitor_thread.start()
        print("🔗 Observer-Avatar bridge started...")
    
    def stop_monitoring(self):
        """Stop monitoring"""
        self.is_running = False
    
    def _monitor_loop(self):
        """Main monitoring loop with emotion-aware timing"""
        while self.is_running:
            try:
                # Process emotion-aware message queue if available
                if EMOTION_FEATURES_AVAILABLE:
                    self._process_emotion_aware_messages()
                
                self._check_files()
                self._show_next_queued_suggestion()
                self._show_next_actionable_suggestion()
                self._show_next_chitchat()
                self._save_state()
                time.sleep(15)
            except Exception as e:
                print(f"Error in observer bridge: {e}")
                time.sleep(60)
    
    def _check_files(self):
        """Check monitored files for changes"""
        current_time = datetime.now()
        
        # Check if it's time to run avatar suggestions (generate new ones)
        if current_time - self.last_suggestions_run > self.suggestions_interval:
            self._run_avatar_suggestions()
            self._run_actionable_suggestions()  # Also check for actionable suggestions
            self.last_suggestions_run = current_time
        
        # Check if it's time to show existing actionable suggestions (higher priority)
        elif current_time - self.last_actionable_show > self.actionable_show_interval:
            self._show_existing_actionable_suggestion()
            self.last_actionable_show = current_time
            
        # Check if it's time to show existing suggestions
        elif current_time - self.last_suggestion_show > self.suggestion_show_interval:
            self._show_existing_suggestion()
            self.last_suggestion_show = current_time
            
        # Check if it's time for idle chatter
        elif current_time - self.last_idle_chatter > self.idle_chatter_interval:
            self._show_idle_chatter()
            self.last_idle_chatter = current_time
            
        # Check if it's time to generate new chit-chat
        elif current_time - self.last_chatter_run > self.chatter_interval:
            self._run_chatter_recipe()
            self.last_chatter_run = current_time
            
        # Check if it's time to run stress wellness analysis (every 30 minutes)
        if not hasattr(self, 'last_stress_check'):
            self.last_stress_check = current_time
        elif current_time - self.last_stress_check > timedelta(minutes=30):
            self._run_stress_wellness_recipe()
            self.last_stress_check = current_time
        
        for filename, category in self.monitored_files.items():
            file_path = self.perception_dir / filename
            
            if not file_path.exists():
                continue
                
            try:
                # Get file modification time
                mod_time = datetime.fromtimestamp(file_path.stat().st_mtime)
                last_check = self.last_check_times.get(filename, datetime.min)
                
                # If file was modified since last check
                if mod_time > last_check:
                    self.last_check_times[filename] = current_time
                    
                    # Read new content
                    new_content = file_path.read_text()
                    old_content = self.last_file_contents.get(filename, "")
                    
                    # Check if content actually changed
                    if new_content != old_content:
                        self.last_file_contents[filename] = new_content
                        self._process_file_change(filename, new_content, old_content, category)
                        
            except Exception as e:
                print(f"Error checking {filename}: {e}")
    
    def get_recent_file_content(self, filename, hours=8):
        """Return only the last N hours of lines from a log file."""
        file_path = self.perception_dir / filename
        if not file_path.exists():
            return ''
        try:
            now = datetime.now()
            lines = []
            with open(file_path, 'r') as f:
                for line in f:
                    # Try to parse timestamp at the start of the line (ISO or similar)
                    # If not possible, just include all lines (fallback)
                    try:
                        ts_str = line.split(' ', 1)[0]
                        ts = datetime.fromisoformat(ts_str)
                        if now - ts <= timedelta(hours=hours):
                            lines.append(line)
                    except Exception:
                        lines.append(line)
            return ''.join(lines)
        except Exception as e:
            print(f"[CONTEXT] Error reading {filename}: {e}")
            return ''

    def _process_emotion_aware_messages(self):
        """Process messages from the emotion-aware message queue"""
        try:
            # Get ready messages from queue
            ready_messages = message_queue.get_ready_messages(limit=3)
            
            for msg in ready_messages:
                delivered = False
                
                if msg.message_type == 'chatter':
                    delivered = self._deliver_chatter_message(msg)
                elif msg.message_type == 'suggestion':
                    delivered = self._deliver_suggestion_message(msg)
                elif msg.message_type == 'wellness':
                    delivered = self._deliver_wellness_message(msg)
                elif msg.message_type == 'notification':
                    delivered = self._deliver_notification_message(msg)
                
                if delivered:
                    message_queue.mark_delivered(msg.id)
                else:
                    message_queue.mark_delivery_attempted(msg.id)
                    
        except Exception as e:
            print(f"Error processing emotion-aware messages: {e}")
    
    def _deliver_chatter_message(self, msg) -> bool:
        """Deliver a chatter message with emotion-aware timing"""
        try:
            content = msg.content
            
            # Check if we should deliver now (additional timing check)
            if not self._should_deliver_message_now(msg.message_type):
                return False
            
            # Show the chatter message
            if avatar_display:
                message_text = content.get('message', 'Hello!')
                avatar_display.show_message(
                    message_text,
                    duration=content.get('duration', 8000),
                    avatar_state=content.get('style', 'talking')
                )
                print(f"📢 Emotion-aware chatter: {message_text}")
                return True
                
        except Exception as e:
            print(f"Error delivering chatter message: {e}")
        
        return False
    
    def _deliver_suggestion_message(self, msg) -> bool:
        """Deliver a suggestion message with emotion-aware timing"""
        try:
            content = msg.content
            
            # Check if we should deliver now
            if not self._should_deliver_message_now(msg.message_type):
                return False
            
            # Show the suggestion
            if avatar_display:
                suggestion_text = content.get('message', 'Here\'s a suggestion')
                avatar_display.show_message(
                    suggestion_text,
                    duration=content.get('duration', 12000),
                    avatar_state=content.get('style', 'talking')
                )
                print(f"💡 Emotion-aware suggestion: {suggestion_text}")
                return True
                
        except Exception as e:
            print(f"Error delivering suggestion message: {e}")
        
        return False
    
    def _deliver_wellness_message(self, msg) -> bool:
        """Deliver a wellness message with emotion-aware timing"""
        try:
            content = msg.content
            
            # Wellness messages have higher priority and looser timing requirements
            if not self._should_deliver_message_now(msg.message_type, lenient=True):
                return False
            
            # Show the wellness message
            if avatar_display:
                wellness_text = content.get('message', 'Take care of yourself!')
                avatar_display.show_message(
                    wellness_text,
                    duration=content.get('duration', 10000),
                    avatar_state=content.get('style', 'talking')
                )
                print(f"🌱 Emotion-aware wellness: {wellness_text}")
                return True
                
        except Exception as e:
            print(f"Error delivering wellness message: {e}")
        
        return False
    
    def _deliver_notification_message(self, msg) -> bool:
        """Deliver a notification message with emotion-aware timing"""
        try:
            content = msg.content
            
            # Check if we should deliver now
            if not self._should_deliver_message_now(msg.message_type):
                return False
            
            # Show the notification
            if avatar_display:
                notification_text = content.get('message', 'Notification')
                avatar_display.show_message(
                    notification_text,
                    duration=content.get('duration', 8000),
                    avatar_state=content.get('style', 'talking')
                )
                print(f"🔔 Emotion-aware notification: {notification_text}")
                return True
                
        except Exception as e:
            print(f"Error delivering notification message: {e}")
        
        return False
    
    def _should_deliver_message_now(self, message_type: str, lenient: bool = False) -> bool:
        """Check if a message should be delivered right now based on emotional timing"""
        try:
            if not EMOTION_FEATURES_AVAILABLE:
                return True  # Fall back to basic mode
            
            # Check if emotion data is available
            if not self.emotion_context.is_emotion_data_available():
                print(f"[TIMING] No emotion data available - allowing {message_type} delivery")
                return True  # Allow all messages when no emotion data
            
            timing_analysis = self.emotion_context.get_interaction_timing_analysis()
            recommendations = timing_analysis.get('recommendations', {})
            
            # For lenient mode (wellness messages), be more permissive
            if lenient:
                receptivity = timing_analysis.get('interaction_receptivity', {}).get(message_type, 0.5)
                return receptivity >= 0.1  # Much lower threshold for wellness
            
            # Check specific recommendations
            if message_type == 'suggestion' and recommendations.get('should_queue_suggestions', False):
                return False
            
            if message_type == 'chatter' and recommendations.get('should_reduce_chatter', False):
                return False
            
            if recommendations.get('pause_non_urgent', False) and message_type in ['chatter', 'notification']:
                return False
            
            # Check minimum receptivity for this message type
            receptivity = timing_analysis.get('interaction_receptivity', {}).get(message_type, 0.5)
            min_receptivity = 0.3 if message_type != 'chatter' else 0.4
            
            return receptivity >= min_receptivity
            
        except Exception as e:
            print(f"[TIMING] Error checking delivery timing: {e} - allowing delivery")
            return True  # Fall back to allowing delivery
    
    def queue_emotion_aware_message(self, message_type: str, content: dict, priority: str = 'medium', 
                                   delay_minutes: int = 0, max_age_hours: float = 24.0):
        """Queue a message for emotion-aware delivery"""
        if not EMOTION_FEATURES_AVAILABLE:
            # Fall back to immediate delivery in basic mode
            if avatar_display:
                message_text = content.get('message', 'Message')
                avatar_display.show_message(
                    message_text,
                    duration=content.get('duration', 8000),
                    avatar_state='talking'
                )
            return None
        
        return message_queue.add_message(
            message_type=message_type,
            content=content,
            priority=priority,
            delay_minutes=delay_minutes,
            max_age_hours=max_age_hours
        )

    def build_recent_context(self, hours=8):
        """Build context from the last N hours of all relevant files."""
        files = ["WORK.md", "LATEST_WORK.md", "INTERACTIONS.md", "CONTRIBUTIONS.md", "ACTIVITY-LOG.md"]
        context = {}
        for fname in files:
            context[fname] = self.get_recent_file_content(fname, hours=hours)
        return context

    def _run_avatar_suggestions(self):
        """Run the avatar suggestions observer recipe with recent context and logging."""
        try:
            # Check emotion-aware timing before running recipe (if emotion data available)
            if EMOTION_FEATURES_AVAILABLE and self.emotion_context.is_emotion_data_available():
                try:
                    timing_analysis = self.emotion_context.get_interaction_timing_analysis()
                    recommendations = timing_analysis.get('recommendations', {})
                    
                    # If we should queue suggestions, reduce frequency of generation
                    if recommendations.get('should_queue_suggestions', False):
                        # Random chance to skip during low receptivity
                        if random.random() < 0.5:  # 50% chance to skip
                            print("⏸️ Delaying suggestion generation due to low receptivity")
                            return
                    
                    # If general pause on non-urgent content
                    if recommendations.get('pause_non_urgent', False):
                        if random.random() < 0.8:  # 80% chance to skip
                            print("⏸️ Pausing suggestion generation - non-urgent mode")
                            return
                except Exception as e:
                    print(f"[SUGGESTIONS] Error getting emotion timing - proceeding: {e}")
            elif EMOTION_FEATURES_AVAILABLE:
                print("[SUGGESTIONS] No emotion data available - proceeding normally")
            
            print("🔍 Running avatar suggestions observer recipe...")
            personality_params = self.get_personality_parameters()
            print(f"[PERSONALITY] Using for suggestions: {personality_params}")
            context = self.build_recent_context(hours=8)
            # Save context to a temp file for the recipe to use
            context_path = self.perception_dir / "RECENT_CONTEXT.json"
            with open(context_path, 'w') as f:
                json.dump(context, f)
            param_args = []
            for key, value in personality_params.items():
                param_args.extend(['--params', f'{key}={value}'])
            param_args.extend(['--params', f'recent_context={context_path}'])
            cmd = [
                "goose", "run", "--no-session", 
                "--recipe", "observers/recipe-avatar-suggestions.yaml"
            ] + param_args
            print(f"🎭 Running with personality: {personality_params['personality_name']}")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            if result.returncode == 0:
                print("✅ Avatar suggestions recipe completed successfully")
                
                # Process suggestions with emotion-aware queueing if available
                if EMOTION_FEATURES_AVAILABLE:
                    self._process_suggestions_with_emotion_aware_queueing()
                else:
                    self._process_new_suggestions()  # Fall back to immediate processing
            else:
                print(f"❌ Avatar suggestions recipe failed: {result.stderr}")
        except subprocess.TimeoutExpired:
            print("⏰ Avatar suggestions recipe timed out")
        except Exception as e:
            print(f"Error running avatar suggestions: {e}")
    
    def _process_suggestions_with_emotion_aware_queueing(self):
        """Process generated suggestions and queue them for emotion-aware delivery"""
        try:
            suggestions = self._parse_suggestions_file()
            if not suggestions:
                return
            
            # Limit the number of suggestions to prevent overwhelming the queue
            MAX_SUGGESTIONS = 5  # Only queue 5 suggestions at a time
            suggestions = suggestions[:MAX_SUGGESTIONS]
            
            if len(suggestions) > MAX_SUGGESTIONS:
                print(f"📝 Limiting suggestions to {MAX_SUGGESTIONS} messages (had {len(suggestions)})")
            
            # Queue each suggestion for emotion-aware delivery
            for suggestion in suggestions:
                if isinstance(suggestion, dict) and 'message' in suggestion:
                    # Determine priority based on suggestion type
                    priority = 'medium'  # Default priority for suggestions
                    suggestion_type = suggestion.get('type', 'general')
                    
                    if suggestion_type in ['urgent', 'important']:
                        priority = 'high'
                    elif suggestion_type in ['reminder', 'tip']:
                        priority = 'low'
                    
                    # Create content dict
                    content = {
                        'message': suggestion['message'],
                        'duration': 12000,
                        'style': 'suggestion',
                        'type': suggestion_type
                    }
                    
                    # Queue the suggestion
                    message_id = self.queue_emotion_aware_message(
                        message_type='suggestion',
                        content=content,
                        priority=priority,
                        delay_minutes=0,  # Let emotion system handle timing
                        max_age_hours=48.0  # Suggestions stay relevant longer
                    )
                    
                    if message_id:
                        print(f"📅 Queued suggestion: {message_id}")
                        
        except Exception as e:
            print(f"Error processing suggestions with emotion-aware queueing: {e}")
    
    def _run_actionable_suggestions(self):
        """Run the actionable suggestions observer recipe"""
        try:
            print("🎯 Running actionable suggestions observer recipe...")
            
            # Get personality parameters
            personality_params = self.get_personality_parameters()
            
            # Build parameter arguments
            param_args = []
            for key, value in personality_params.items():
                param_args.extend(['--params', f'{key}={value}'])
            
            # Run the goose recipe with personality parameters
            cmd = [
                "goose", "run", "--no-session", 
                "--recipe", "observers/recipe-actionable-suggestions.yaml"
            ] + param_args
            
            print(f"🎭 Running actionable suggestions with personality: {personality_params['personality_name']}")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if result.returncode == 0:
                print("✅ Actionable suggestions recipe completed successfully")
                self._process_actionable_suggestions()
            else:
                print(f"❌ Actionable suggestions recipe failed: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            print("⏰ Actionable suggestions recipe timed out")
        except Exception as e:
            print(f"Error running actionable suggestions: {e}")
    
    def _run_chatter_recipe(self):
        """Run the chit-chat recipe to generate contextual casual messages"""
        try:
            # Check emotion-aware timing before running recipe (if emotion data available)
            if EMOTION_FEATURES_AVAILABLE and self.emotion_context.is_emotion_data_available():
                try:
                    timing_analysis = self.emotion_context.get_interaction_timing_analysis()
                    recommendations = timing_analysis.get('recommendations', {})
                    
                    # Be less aggressive about blocking chatter - allow supportive messages
                    chatter_receptivity = timing_analysis.get('interaction_receptivity', {}).get('chatter', 0.5)
                    
                    # Only block chatter if receptivity is extremely low AND recommendations are very restrictive
                    if recommendations.get('should_reduce_chatter', False) and chatter_receptivity < 0.05:
                        # Still allow occasional supportive chatter even when recommended to reduce
                        if random.random() < 0.8:  # 80% chance to skip when extremely low receptivity
                            print("⏸️ Skipping chatter generation due to very low emotional receptivity")
                            return
                        else:
                            print("💬 Generating supportive chatter despite low receptivity")
                    
                    # For moderate low receptivity, just reduce frequency but don't block entirely
                    elif chatter_receptivity < 0.2:
                        if random.random() < 0.5:  # 50% chance to skip (reduced from 70%)
                            print("⏸️ Reducing chatter frequency due to emotional state")
                            return
                except Exception as e:
                    print(f"[CHATTER] Error getting emotion timing - proceeding: {e}")
            elif EMOTION_FEATURES_AVAILABLE:
                print("[CHATTER] No emotion data available - proceeding normally")
            
            print("💬 Running avatar chit-chat recipe...")
            
            # Get personality parameters
            personality_params = self.get_personality_parameters()
            
            # Build parameter arguments
            param_args = []
            for key, value in personality_params.items():
                param_args.extend(['--params', f'{key}={value}'])
            
            # Run the goose recipe with personality parameters
            cmd = [
                "goose", "run", "--no-session", 
                "--recipe", "observers/recipe-avatar-chatter.yaml"
            ] + param_args
            
            print(f"🎭 Running chatter with personality: {personality_params['personality_name']}")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                print("✅ Avatar chit-chat recipe completed successfully")
                
                # If emotion features are available, process generated chatter with smart queueing
                if EMOTION_FEATURES_AVAILABLE:
                    self._process_chatter_with_emotion_aware_queueing()
            else:
                print(f"❌ Avatar chit-chat recipe failed: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            print("⏰ Avatar chit-chat recipe timed out")
        except Exception as e:
            print(f"Error running avatar chit-chat: {e}")
    
    def _process_chatter_with_emotion_aware_queueing(self):
        """Process generated chatter and queue it for emotion-aware delivery"""
        try:
            messages = self._parse_chatter_file()
            if not messages:
                return
            
            # Limit the number of messages to prevent overwhelming the queue
            MAX_CHATTER_MESSAGES = 3  # Only queue 3 messages at a time
            messages = messages[:MAX_CHATTER_MESSAGES]
            
            if len(messages) > MAX_CHATTER_MESSAGES:
                print(f"📝 Limiting chatter to {MAX_CHATTER_MESSAGES} messages (had {len(messages)})")
            
            # Queue each message for emotion-aware delivery
            for message in messages:
                if isinstance(message, str) and message.strip():
                    # Create content dict
                    content = {
                        'message': message.strip(),
                        'duration': 8000,
                        'style': 'normal'
                    }
                    
                    # Queue the message
                    message_id = self.queue_emotion_aware_message(
                        message_type='chatter',
                        content=content,
                        priority='low',  # Chatter is generally low priority
                        delay_minutes=0,  # Let emotion system handle timing
                        max_age_hours=6.0  # Chatter becomes stale quickly
                    )
                    
                    if message_id:
                        print(f"📅 Queued chatter message: {message_id}")
                        
        except Exception as e:
            print(f"Error processing chatter with emotion-aware queueing: {e}")
    
    def _parse_suggestions_file(self):
        """Parse the AVATAR_SUGGESTIONS.json file and return suggestions"""
        suggestions_file = self.perception_dir / "AVATAR_SUGGESTIONS.json"
        suggestions = []
        
        if not suggestions_file.exists():
            return suggestions
            
        try:
            with open(suggestions_file, 'r') as f:
                data = json.load(f)
                raw_suggestions = data.get("suggestions", [])
                
                # Convert to the expected format with type and message
                for suggestion_text in raw_suggestions:
                    suggestions.append({
                        'type': 'general',  # Default type for non-actionable suggestions
                        'message': suggestion_text
                    })
            
            return suggestions
        except Exception as e:
            print(f"Error parsing suggestions file: {e}")
            return []
    
    def _parse_chatter_file(self):
        """Parse the AVATAR_CHATTER.md file and return casual messages"""
        chatter_file = self.perception_dir / "AVATAR_CHATTER.md"
        messages = []
        
        if not chatter_file.exists():
            return messages
            
        try:
            content = chatter_file.read_text()
            lines = content.strip().split('\n')
            
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    messages.append(line)
            
            return messages
        except Exception as e:
            print(f"Error parsing chatter file: {e}")
            return []
    
    def _parse_actionable_suggestions_file(self):
        """Parse the ACTIONABLE_SUGGESTIONS.json file and return actionable suggestions"""
        actionable_file = self.perception_dir / "ACTIONABLE_SUGGESTIONS.json"
        suggestions = []
        
        if not actionable_file.exists():
            return suggestions
            
        try:
            with open(actionable_file, 'r') as f:
                data = json.load(f)
                raw_suggestions = data.get("actionable_suggestions", [])
            
            # Validate that action commands exist
            from pathlib import Path
            actions_dir = Path(__file__).parent.parent / "actions"
            available_actions = set()
            if actions_dir.exists():
                available_actions = {f.stem for f in actions_dir.glob("*.yaml")}
            
            # Filter to only valid suggestions
            valid_suggestions = []
            invalid_count = 0
            for suggestion in raw_suggestions:
                action_command = suggestion.get('action_command', '')
                if action_command in available_actions:
                    valid_suggestions.append(suggestion)
                else:
                    invalid_count += 1
                    print(f"⚠️ Skipping actionable suggestion with missing action: {action_command}")
            
            if invalid_count > 0:
                print(f"📋 Filtered {invalid_count} invalid actionable suggestions, {len(valid_suggestions)} valid ones remain")
            
            return valid_suggestions
        except Exception as e:
            print(f"Error parsing actionable suggestions file: {e}")
            return []
    
    def _process_actionable_suggestions(self):
        """Process newly generated actionable suggestions"""
        actionable_suggestions = self._parse_actionable_suggestions_file()
        
        if actionable_suggestions:
            # Pick the most relevant/urgent actionable suggestion
            suggestion = random.choice(actionable_suggestions)
            
            # Show immediately - actionable suggestions are high priority!
            self._show_actionable_suggestion(suggestion)
            print(f"🎯 Immediately showing actionable suggestion: {suggestion['message']}")
    
    def _show_actionable_suggestion(self, suggestion):
        """Show an actionable suggestion with action buttons"""
        try:
            # Pass through any additional parameters specified in the suggestion
            action_data = {
                'action_type': suggestion.get('action_type'),
                'action_command': suggestion.get('action_command'),
                'observation_type': suggestion.get('observation_type'),
                'parameters': suggestion.get('parameters', {})
            }
            
            # Use the thread-safe function instead of direct avatar_instance call
            from . import avatar_display
            avatar_display.show_actionable_message(
                suggestion['message'], 
                action_data,
                avatar_state='pointing'
            )
            
        except Exception as e:
            print(f"Error showing actionable suggestion: {e}")
    
    def _process_new_suggestions(self):
        """Process newly generated suggestions and queue if new."""
        suggestions = self._parse_suggestions_file()
        if not suggestions:
            return
        for suggestion in suggestions:
            suggestion_hash = self._hash_suggestion(suggestion)
            if suggestion_hash not in self.shown_suggestions and suggestion_hash not in self.completed_suggestions and suggestion_hash not in self.dismissed_suggestions:
                self.suggestion_queue.append(suggestion)
        self._save_state()
    
    def _show_existing_actionable_suggestion(self):
        """Show an actionable suggestion from the existing pool"""
        actionable_suggestions = self._parse_actionable_suggestions_file()
        
        if not actionable_suggestions:
            print("📭 No actionable suggestions available to show")
            return
            
        # Show actionable suggestions with high probability - these are important!
        if random.random() < self.actionable_suggestions_chance:  # 70% chance to show
            # Filter out recently shown suggestions to cycle through them
            fresh_suggestions = [
                s for s in actionable_suggestions 
                if s['action_command'] not in self.shown_actionable_suggestions
            ]
            
            # If we've shown everything recently, reset the tracking
            if not fresh_suggestions:
                fresh_suggestions = actionable_suggestions
                self.shown_actionable_suggestions = set()
                print("🔄 Cycling through actionable suggestions - all have been shown recently")
            
            # Pick a fresh suggestion
            suggestion = random.choice(fresh_suggestions)
            
            # Track this suggestion
            self.shown_actionable_suggestions.add(suggestion['action_command'])
            if len(self.shown_actionable_suggestions) > self.max_remembered_actionable:
                # Remove oldest by converting to list, popping, and converting back
                temp = list(self.shown_actionable_suggestions)
                temp.pop(0)
                self.shown_actionable_suggestions = set(temp)
            
            self._show_actionable_suggestion(suggestion)
            print(f"🎯 Showing actionable suggestion: {suggestion['action_type']} - {suggestion['message'][:60]}...")
        else:
            print("🎲 Skipped showing actionable suggestion (probability)")
    
    def _show_existing_suggestion(self):
        """Show a suggestion from the existing pool if new and not shown recently."""
        suggestions = self._parse_suggestions_file()
        if not suggestions:
            return
        for suggestion in suggestions:
            suggestion_hash = self._hash_suggestion(suggestion)
            if suggestion_hash not in self.shown_suggestions:
                self.suggestion_queue.append(suggestion)
                break  # Only queue one at a time
    
    def _show_suggestion(self, suggestion):
        """Helper method to show a suggestion with proper avatar state"""
        # Map suggestion types to valid avatar states
        # Valid states: idle, talking, pointing, sleeping
        suggestion_types = {
            'productivity': 'pointing',
            'collaboration': 'pointing', 
            'focus': 'pointing',
            'attention': 'pointing',
            'optimization': 'pointing',
            'break': 'talking',
            'system': 'pointing',
            'general': 'talking'
        }
        
        suggestion_type = suggestion_types.get(suggestion['type'], 'pointing')
        message = suggestion['message']
        
        # Use the thread-safe function instead of direct call
        from . import avatar_display
        avatar_display.show_suggestion(suggestion_type, message)
    
    def _show_idle_chatter(self):
        """Show casual idle chatter from recipe-generated content"""
        # Show idle chatter with reasonable probability since it's contextual now
        if random.random() < 0.4:  # 40% chance for idle chatter (reduced from 50%)
            chatter_messages = self._parse_chatter_file()
            if chatter_messages:
                # Just pick a random message - no need to access avatar instance from background thread
                message = random.choice(chatter_messages)
                
                # Use the thread-safe function instead of direct call
                from . import avatar_display
                avatar_display.show_message(message, 4000)
                print(f"💬 Showed casual chatter: {message[:50]}...")
    
    def _process_file_change(self, filename, new_content, old_content, category):
        try:
            # Handle avatar suggestions file updates
            if filename == 'AVATAR_SUGGESTIONS.json':
                self._process_new_suggestions()
                return
            # For recipe files, only regenerate if emotional state changed
            if filename in ['recipe-avatar-suggestions.yaml', 'recipe-actionable-suggestions.yaml', 'recipe-avatar-chatter.yaml']:
                if self._has_emotion_state_changed():
                    print("[EMOTION] Emotional state changed - regenerating suggestions with new context")
                    self.on_context_or_recipe_change()
                else:
                    print("[EMOTION] Recipe file changed but emotional state unchanged - skipping regeneration")
                return
            # For content files, use lighter context update
            if filename in ['WORK.md', 'LATEST_WORK.md', 'INTERACTIONS.md', 'CONTRIBUTIONS.md', 'ACTIVITY-LOG.md']:
                # Only regenerate if emotional state changed OR it's been a while since last regeneration
                if self._has_emotion_state_changed():
                    print("[EMOTION] Emotional state changed - regenerating suggestions")
                    self.on_context_or_recipe_change()
                else:
                    # Reduce log spam - only print this occasionally
                    if random.random() < 0.1:  # 10% chance
                        print("[EMOTION] Content updated but emotional state unchanged - keeping existing suggestions")
                return
            # Show a contextual message (unchanged)
            if random.random() > 0.3:
                return
            from . import avatar_display
            if filename == 'LATEST_WORK.md':
                avatar_display.show_message("📝 I see you're updating your current work focus...")
            elif filename == 'INTERACTIONS.md':
                avatar_display.show_message("🤝 New interaction data updated...")
            elif filename == 'CONTRIBUTIONS.md':
                avatar_display.show_message("📈 Your contribution patterns have been updated...")
        except Exception as e:
            print(f"Error processing {filename} change: {e}")
    
    def get_personality_parameters(self):
        """Get personality parameters for recipes with emotion-aware adaptation"""
        try:
            from pathlib import Path
            import json
            import sys
            import os
            
            # Add the parent directory to sys.path to import emotion_context
            parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            if parent_dir not in sys.path:
                sys.path.append(parent_dir)
            
            try:
                from emotion_context import emotion_context as emotion_ctx
                emotion_context_data = emotion_ctx.get_current_emotion_context()
                modifiers = emotion_context_data.get('personality_modifiers', {})
                print(f"[EMOTION] Current emotion context: {emotion_context_data['recent_emotion']} (energy: {emotion_context_data['energy_level']}, stress: {emotion_context_data['stress_level']})")
            except Exception as e:
                print(f"[EMOTION] Could not load emotion context: {e}")
                emotion_context_data = {}
                modifiers = {}
            
            settings_path = Path.home() / ".local/share/goose-perception/PERSONALITY_SETTINGS.json"
            if settings_path.exists():
                try:
                    with open(settings_path, 'r') as f:
                        settings = json.load(f)
                    saved_personality = settings.get("current_personality", "comedian")
                    print(f"[PERSONALITY] Loaded from settings: {saved_personality}")
                    personalities_path = Path(__file__).parent / "personalities.json"
                    if personalities_path.exists():
                        with open(personalities_path, 'r') as f:
                            personalities_data = json.load(f)
                            personality_data = personalities_data.get("personalities", {}).get(saved_personality, {})
                            if personality_data:
                                print(f"[PERSONALITY] Using personality data: {personality_data.get('name', saved_personality.title())}")
                                base_params = {
                                    'personality_name': personality_data.get('name', saved_personality.title()),
                                    'personality_style': personality_data.get('suggestion_style', ''),
                                    'personality_tone': personality_data.get('tone', ''),
                                    'personality_priorities': ', '.join(personality_data.get('priorities', [])),
                                    'personality_phrases': ', '.join(personality_data.get('example_phrases', []))
                                }
                                # Apply emotion-aware modifications
                                return self._apply_emotion_modifiers(base_params, emotion_context_data, modifiers)
                            else:
                                print(f"[PERSONALITY] No data found for personality: {saved_personality}, falling back to default.")
                except Exception as e:
                    print(f"[PERSONALITY] Error reading personality settings: {e}")
            else:
                print("[PERSONALITY] Settings file not found, using default personality.")
            
            # Fallback to professional if available, else comedian
            fallback_personality = "professional"
            personalities_path = Path(__file__).parent / "personalities.json"
            if personalities_path.exists():
                with open(personalities_path, 'r') as f:
                    personalities_data = json.load(f)
                    if fallback_personality in personalities_data.get("personalities", {}):
                        print(f"[PERSONALITY] Fallback to: {fallback_personality}")
                        personality_data = personalities_data["personalities"][fallback_personality]
                        base_params = {
                            'personality_name': personality_data.get('name', fallback_personality.title()),
                            'personality_style': personality_data.get('suggestion_style', ''),
                            'personality_tone': personality_data.get('tone', ''),
                            'personality_priorities': ', '.join(personality_data.get('priorities', [])),
                            'personality_phrases': ', '.join(personality_data.get('example_phrases', []))
                        }
                        return self._apply_emotion_modifiers(base_params, emotion_context_data, modifiers)
            
            print("[PERSONALITY] Fallback to comedian personality.")
            base_params = {
                'personality_name': 'Comedian',
                'personality_style': 'Everything is an opportunity for humor. Makes jokes about coding, work situations, and daily activities. Keeps things light and funny.',
                'personality_tone': 'humorous, witty, entertaining, lighthearted',
                'personality_priorities': 'humor, entertainment, making people laugh, finding the funny side',
                'personality_phrases': 'Why did the developer, Speaking of comedy, Here\'s a joke for you, Plot twist comedy, Funny thing about'
            }
            return self._apply_emotion_modifiers(base_params, emotion_context_data, modifiers)
            
        except Exception as e:
            print(f"[PERSONALITY] Error getting personality parameters: {e}")
            return {
                'personality_name': 'Comedian',
                'personality_style': 'Everything is an opportunity for humor. Makes jokes about coding, work situations, and daily activities.',
                'personality_tone': 'humorous, witty, entertaining',
                'personality_priorities': 'humor, entertainment, making people laugh',
                'personality_phrases': 'Why did the developer, Speaking of comedy, Here\'s a joke for you'
            }
    
    def _apply_emotion_modifiers(self, base_params, emotion_context, modifiers):
        """Apply emotion-based modifications to personality parameters"""
        try:
            if not emotion_context or not modifiers:
                # Add emotion context info even if no modifications
                base_params['emotion_context'] = "No emotion data available - using default personality"
                return base_params
            
            recent_emotion = emotion_context.get('recent_emotion', 'neutral')
            energy_level = emotion_context.get('energy_level', 'medium')
            stress_level = emotion_context.get('stress_level', 'low')
            
            # Get modifier values
            energy_boost = modifiers.get('energy_boost', 0.0)
            supportiveness_boost = modifiers.get('supportiveness_boost', 0.0)
            humor_adjustment = modifiers.get('humor_adjustment', 0.0)
            focus_intensity = modifiers.get('focus_intensity', 0.0)
            
            # Apply modifications to tone
            modified_tone = base_params['personality_tone']
            tone_additions = []
            
            if energy_boost > 0.5:
                tone_additions.append("energetic")
                tone_additions.append("enthusiastic")
            elif energy_boost < -0.5:
                tone_additions.append("gentle")
                tone_additions.append("calm")
            
            if supportiveness_boost > 0.5:
                tone_additions.append("supportive")
                tone_additions.append("encouraging")
                tone_additions.append("understanding")
            
            if humor_adjustment < -0.3:
                tone_additions.append("focused")
                tone_additions.append("serious")
            elif humor_adjustment > 0.3:
                tone_additions.append("playful")
                tone_additions.append("witty")
            
            if focus_intensity > 0.5:
                tone_additions.append("direct")
                tone_additions.append("practical")
            
            if tone_additions:
                modified_tone = f"{modified_tone}, {', '.join(tone_additions)}"
            
            # Apply modifications to style
            modified_style = base_params['personality_style']
            
            if recent_emotion in ['sad', 'tired'] and supportiveness_boost > 0.3:
                modified_style += " Adapts to provide extra encouragement and gentle support when you seem tired or down."
            elif recent_emotion == 'happy' and energy_boost > 0.3:
                modified_style += " Matches your positive energy with more enthusiasm and celebratory comments."
            elif stress_level == 'high' and focus_intensity > 0.3:
                modified_style += " Becomes more focused and practical during stressful times, offering concrete help rather than just casual chat."
            
            # Apply modifications to priorities
            modified_priorities = base_params['personality_priorities']
            priority_additions = []
            
            if supportiveness_boost > 0.5:
                priority_additions.append("emotional support")
                priority_additions.append("encouragement")
            
            if focus_intensity > 0.5:
                priority_additions.append("practical assistance")
                priority_additions.append("problem-solving")
            
            if priority_additions:
                modified_priorities = f"{modified_priorities}, {', '.join(priority_additions)}"
            
            # Create emotion context description for the recipe
            emotion_description = f"Current emotion: {recent_emotion} | Energy: {energy_level} | Stress: {stress_level}"
            if abs(energy_boost) > 0.3 or abs(supportiveness_boost) > 0.3 or abs(humor_adjustment) > 0.3:
                emotion_description += f" | Personality adapted based on emotional state"
            
            return {
                'personality_name': base_params['personality_name'],
                'personality_style': modified_style,
                'personality_tone': modified_tone,
                'personality_priorities': modified_priorities,
                'personality_phrases': base_params['personality_phrases'],
                'emotion_context': emotion_description,
                'recent_emotion': recent_emotion,
                'energy_level': energy_level,
                'stress_level': stress_level,
                'emotion_modifiers': {
                    'energy_boost': energy_boost,
                    'supportiveness_boost': supportiveness_boost,
                    'humor_adjustment': humor_adjustment,
                    'focus_intensity': focus_intensity
                }
            }
            
        except Exception as e:
            print(f"[EMOTION] Error applying emotion modifiers: {e}")
            base_params['emotion_context'] = f"Error applying emotion context: {e}"
            return base_params
    
    def get_stress_wellness_parameters(self):
        """Get parameters for stress management and wellness recipes"""
        try:
            import sys
            import os
            
            # Add the parent directory to sys.path to import emotion_context
            parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            if parent_dir not in sys.path:
                sys.path.append(parent_dir)
            
            from emotion_context import emotion_context
            
            stress_analysis = emotion_context.get_stress_analysis()
            context_data = emotion_context.get_current_emotion_context()
            receptivity = emotion_context.get_receptivity_score()
            should_suggest = emotion_context.should_suggest_break_now()
            
            # Convert duration to hours and minutes
            duration_total_minutes = stress_analysis['duration_minutes']
            duration_hours = duration_total_minutes // 60
            duration_minutes = duration_total_minutes % 60
            
            # Format time since positive emotion
            time_since_positive = stress_analysis['time_since_last_positive']
            if time_since_positive is None:
                time_since_positive_str = "unknown"
            elif time_since_positive < 60:
                time_since_positive_str = f"{time_since_positive:.0f} minutes"
            else:
                time_since_positive_str = f"{time_since_positive/60:.1f} hours"
            
            return {
                'stress_score': stress_analysis['stress_score'],
                'stress_level': stress_analysis['stress_level'],
                'intervention_type': stress_analysis['intervention_type'],
                'duration_hours': duration_hours,
                'duration_minutes': duration_minutes,
                'time_since_positive': time_since_positive_str,
                'stress_patterns': stress_analysis['patterns'],
                'receptivity_score': receptivity,
                'should_suggest_break': should_suggest,
                'recent_emotion': context_data['recent_emotion'],
                'energy_level': context_data['energy_level']
            }
            
        except Exception as e:
            print(f"[STRESS] Error getting stress wellness parameters: {e}")
            return {
                'stress_score': 0.0,
                'stress_level': 'low',
                'intervention_type': 'none',
                'duration_hours': 0,
                'duration_minutes': 0,
                'time_since_positive': 'unknown',
                'stress_patterns': {},
                'receptivity_score': 0.5,
                'should_suggest_break': False,
                'recent_emotion': 'neutral',
                'energy_level': 'medium'
            }
    
    def _run_stress_wellness_recipe(self):
        """Run the stress wellness recipe if conditions are appropriate"""
        try:
            import sys
            import os
            
            # Add the parent directory to sys.path to import emotion_context
            parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            if parent_dir not in sys.path:
                sys.path.append(parent_dir)
            
            from emotion_context import emotion_context
            
            should_suggest = emotion_context.should_suggest_break_now()
            stress_analysis = emotion_context.get_stress_analysis()
            
            # Only run wellness recipe if intervention is needed OR for periodic monitoring
            if should_suggest or stress_analysis['intervention_needed']:
                print("🧘 Running stress & wellness analysis...")
                
                params = self.get_stress_wellness_parameters()
                
                # Log the stress context
                print(f"[STRESS] Current stress level: {params['stress_level']} (score: {params['stress_score']:.2f})")
                if params['should_suggest_break']:
                    print(f"[WELLNESS] Intervention recommended: {params['intervention_type']}")
                
                # Build parameter arguments
                param_args = []
                for key, value in params.items():
                    param_args.extend(['--params', f'{key}={value}'])
                
                # Run the goose recipe
                cmd = [
                    "goose", "run", "--no-session", 
                    "--recipe", "observers/recipe-stress-wellness.yaml"
                ] + param_args
                
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                
                if result.returncode == 0:
                    print("✅ Stress wellness analysis completed")
                    return True
                else:
                    print(f"❌ Stress wellness recipe failed: {result.stderr}")
                    return False
            
            return True  # No intervention needed is success
            
        except Exception as e:
            print(f"❌ Error running stress wellness recipe: {e}")
            return False

    def trigger_contextual_message(self):
        """Trigger a contextual message from recipes"""
        if avatar_display is None:
            return
        
        # Try to show a chit-chat message from recipe-generated content
        chatter_messages = self._parse_chatter_file()
        if chatter_messages:
            message = random.choice(chatter_messages)
            avatar_display.show_message(message, 4000)
        else:
            # Fallback to simple interaction if no chatter available
            avatar_display.show_message("👋 How's it going?", 3000)

    def clear_old_suggestions(self):
        """Clear old suggestion files to ensure only personality-appropriate content remains"""
        try:
            suggestion_files = [
                self.perception_dir / "AVATAR_SUGGESTIONS.json",
                self.perception_dir / "ACTIONABLE_SUGGESTIONS.json", 
                self.perception_dir / "AVATAR_CHATTER.md"
            ]
            
            for file_path in suggestion_files:
                if file_path.exists():
                    file_path.unlink()
                    print(f"🗑️ Cleared old suggestions from {file_path.name}")
                    
        except Exception as e:
            print(f"⚠️ Error clearing old suggestions: {e}")

    def _remove_suggestion_from_file(self, suggestion, file_path, key):
        """Remove a suggestion from the given JSON file under the specified key."""
        try:
            if not file_path.exists():
                return
            with open(file_path, 'r') as f:
                data = json.load(f)
            suggestions = data.get(key, [])
            # Remove the first matching suggestion (by string match)
            if isinstance(suggestion, dict):
                msg = suggestion.get('message', '')
            else:
                msg = suggestion
            new_suggestions = [s for s in suggestions if (s if isinstance(s, str) else s.get('message', '')) != msg]
            data[key] = new_suggestions
            if new_suggestions:
                with open(file_path, 'w') as f:
                    json.dump(data, f, indent=2)
            else:
                file_path.unlink()  # Delete file if empty
        except Exception as e:
            print(f"⚠️ Error removing suggestion from {file_path}: {e}")

    def _remove_chitchat_from_file(self, message, file_path):
        """Remove a chit-chat message from the .md file."""
        try:
            if not file_path.exists():
                return
            lines = file_path.read_text().splitlines()
            # Remove the first matching message line
            new_lines = [line for line in lines if line.strip() != message.strip()]
            if new_lines:
                file_path.write_text('\n'.join(new_lines))
            else:
                file_path.unlink()
        except Exception as e:
            print(f"⚠️ Error removing chit-chat from {file_path}: {e}")

    def _show_next_queued_suggestion(self):
        now = datetime.now()
        if self.suggestion_queue and (now - self.last_suggestion_display > self.min_suggestion_interval):
            suggestion = self.suggestion_queue.pop(0)
            self._show_suggestion(suggestion)
            suggestion_hash = self._hash_suggestion(suggestion)
            self.shown_suggestions.add(suggestion_hash)
            self.last_suggestion_display = now
            # Remove from AVATAR_SUGGESTIONS.json
            suggestions_path = self.perception_dir / "AVATAR_SUGGESTIONS.json"
            self._remove_suggestion_from_file(suggestion, suggestions_path, "suggestions")
            self._save_state()

    def _show_next_actionable_suggestion(self):
        now = datetime.now()
        if self.actionable_suggestion_queue and (now - self.last_actionable_display > self.min_actionable_interval):
            suggestion = self.actionable_suggestion_queue.pop(0)
            self._show_actionable_suggestion(suggestion)
            suggestion_hash = self._hash_suggestion(suggestion)
            self.shown_actionable_suggestions.add(suggestion_hash)
            self.last_actionable_display = now
            # Remove from ACTIONABLE_SUGGESTIONS.json
            actionable_path = self.perception_dir / "ACTIONABLE_SUGGESTIONS.json"
            self._remove_suggestion_from_file(suggestion, actionable_path, "actionable_suggestions")
            self._save_state()

    def _show_next_chitchat(self):
        now = datetime.now()
        if self.chitchat_queue and (now - self.last_chitchat_display > self.min_chitchat_interval):
            message = self.chitchat_queue.pop(0)
            self._show_chitchat(message)
            message_hash = self._hash_chitchat(message)
            self.shown_chitchat.add(message_hash)
            self.last_chitchat_display = now
            # Remove from AVATAR_CHATTER.md
            chatter_path = self.perception_dir / "AVATAR_CHATTER.md"
            self._remove_chitchat_from_file(message, chatter_path)
            self._save_state()

    def _show_chitchat(self, message):
        from . import avatar_display
        avatar_display.show_message(message, 4000)

    def _hash_suggestion(self, suggestion):
        s = f"{suggestion.get('type','')}|{suggestion.get('message','')}"
        return hashlib.sha256(s.encode('utf-8')).hexdigest()

    def _hash_chitchat(self, message):
        return hashlib.sha256(message.encode('utf-8')).hexdigest()

    def record_feedback(self, suggestion, feedback_type):
        """Record user feedback (accepted/rejected) for a suggestion, storing the full suggestion."""
        feedback_file = self.state_dir / "avatar_feedback.json"
        entry = {
            "suggestion": suggestion,  # Store the full suggestion dict or string
            "type": suggestion.get('type', 'unknown') if isinstance(suggestion, dict) else 'unknown',
            "timestamp": datetime.now().isoformat(),
            "feedback": feedback_type
        }
        # Load existing feedback
        if feedback_file.exists():
            with open(feedback_file, "r") as f:
                try:
                    data = json.load(f)
                except Exception:
                    data = {"feedback": []}
        else:
            data = {"feedback": []}
        data["feedback"].append(entry)
        with open(feedback_file, "w") as f:
            json.dump(data, f, indent=2)

    def mark_suggestion_completed(self, suggestion):
        suggestion_hash = self._hash_suggestion(suggestion)
        self.completed_suggestions.add(suggestion_hash)
        self.record_feedback(suggestion, "accepted")
        self._save_state()

    def mark_suggestion_dismissed(self, suggestion):
        suggestion_hash = self._hash_suggestion(suggestion)
        self.dismissed_suggestions.add(suggestion_hash)
        self.record_feedback(suggestion, "rejected")
        self._save_state()

    def _save_state(self):
        state = {
            'suggestion_queue': self.suggestion_queue,
            'shown_suggestions': list(self.shown_suggestions),
            'last_suggestion_display': self.last_suggestion_display,
            'actionable_suggestion_queue': self.actionable_suggestion_queue,
            'shown_actionable_suggestions': list(self.shown_actionable_suggestions),
            'last_actionable_display': self.last_actionable_display,
            'chitchat_queue': self.chitchat_queue,
            'shown_chitchat': list(self.shown_chitchat),
            'last_chitchat_display': self.last_chitchat_display,
            'completed_suggestions': list(self.completed_suggestions),
            'dismissed_suggestions': list(self.dismissed_suggestions),
        }
        with open(self.state_dir / "avatar_state.pkl", "wb") as f:
            pickle.dump(state, f)

    def _load_state(self):
        try:
            state_file = self.state_dir / "avatar_state.pkl"
            if state_file.exists():
                with open(state_file, "rb") as f:
                    state = pickle.load(f)
                self.suggestion_queue = state.get('suggestion_queue', [])
                self.shown_suggestions = set(state.get('shown_suggestions', []))
                self.last_suggestion_display = state.get('last_suggestion_display', datetime.min)
                self.actionable_suggestion_queue = state.get('actionable_suggestion_queue', [])
                self.shown_actionable_suggestions = set(state.get('shown_actionable_suggestions', []))
                self.last_actionable_display = state.get('last_actionable_display', datetime.min)
                self.chitchat_queue = state.get('chitchat_queue', [])
                self.shown_chitchat = set(state.get('shown_chitchat', []))
                self.last_chitchat_display = state.get('last_chitchat_display', datetime.min)
                self.completed_suggestions = set(state.get('completed_suggestions', []))
                self.dismissed_suggestions = set(state.get('dismissed_suggestions', []))
        except Exception as e:
            print(f"⚠️ Error loading avatar state: {e}")

    def clear_all_state(self):
        """Clear all suggestion, actionable, and chit-chat files and reset queues/sets. Also delete AVATAR_MESSAGE.json and other legacy message files."""
        self.clear_old_suggestions()
        # Remove legacy/auxiliary message files
        legacy_files = [
            self.perception_dir / "AVATAR_MESSAGE.json",
            self.perception_dir / "AVATAR_MESSAGE.md",
            self.perception_dir / "AVATAR_MESSAGE.txt"
        ]
        for file_path in legacy_files:
            if file_path.exists():
                file_path.unlink()
                print(f"🗑️ Cleared legacy message file: {file_path.name}")
        self.suggestion_queue = []
        self.shown_suggestions = set()
        self.last_suggestion_display = datetime.min
        self.actionable_suggestion_queue = []
        self.shown_actionable_suggestions = set()
        self.last_actionable_display = datetime.min
        self.chitchat_queue = []
        self.shown_chitchat = set()
        self.last_chitchat_display = datetime.min
        self.completed_suggestions = set()
        self.dismissed_suggestions = set()
        self._save_state()
        print("[STATE] All suggestion/chitchat state cleared.")

    def on_personality_switch(self):
        """Call this after personality switch to clear state and regenerate suggestions."""
        self.clear_all_state()
        self._run_avatar_suggestions()
        self._run_actionable_suggestions()
        self._run_chatter_recipe()
        print("[PERSONALITY] Regenerated all suggestions after personality switch.")

    def on_context_or_recipe_change(self):
        """Call this after context or recipe change to clear state and regenerate suggestions."""
        print("[CONTEXT/RECIPE] Regenerating suggestions after emotional context change.")
        self.clear_all_state()
        self._run_avatar_suggestions()
        self._run_actionable_suggestions()
        self._run_chatter_recipe()
        print("[CONTEXT/RECIPE] Regenerated all suggestions after context/recipe change.")

    def _get_emotion_state_snapshot(self):
        """Get a snapshot of current emotional state for comparison"""
        try:
            if self.emotion_context and self.emotion_context.is_emotion_data_available():
                context = self.emotion_context.get_current_emotion_context()
                return {
                    'recent_emotion': context.get('recent_emotion'),
                    'energy_level': context.get('energy_level'),
                    'stress_level': context.get('stress_level'),
                    'dominant_emotion': context.get('dominant_emotion')
                }
        except Exception as e:
            print(f"[EMOTION] Error getting emotion snapshot: {e}")
        return None

    def _has_emotion_state_changed(self):
        """Check if emotional state has significantly changed since last check"""
        current_state = self._get_emotion_state_snapshot()
        
        if self.previous_emotion_state is None and current_state is None:
            return False  # No change (both None)
        
        if self.previous_emotion_state is None or current_state is None:
            self.previous_emotion_state = current_state
            return True  # State availability changed
        
        # Add a timestamp and count for more intelligent change detection
        if not hasattr(self, 'last_emotion_change_time'):
            self.last_emotion_change_time = datetime.now()
            self.emotion_change_count = 0
        
        # Only check for SIGNIFICANT changes, not every minor emotion fluctuation
        significant_change = False
        
        # Major emotion category changes (positive/negative/neutral shifts)
        prev_emotion = self.previous_emotion_state['recent_emotion']
        curr_emotion = current_state['recent_emotion']
        
        # Group emotions into broader categories to reduce sensitivity
        positive_emotions = {'happy', 'content', 'surprised'}
        negative_emotions = {'sad', 'tired', 'serious', 'angry', 'fear'}
        neutral_emotions = {'neutral', 'uncertain'}
        
        def get_emotion_category(emotion):
            if emotion in positive_emotions:
                return 'positive'
            elif emotion in negative_emotions:
                return 'negative'
            else:
                return 'neutral'
        
        prev_category = get_emotion_category(prev_emotion)
        curr_category = get_emotion_category(curr_emotion)
        
        # Only trigger on category changes OR significant sustained changes
        if prev_category != curr_category:
            # Reset change tracking for category changes
            time_since_last = (datetime.now() - self.last_emotion_change_time).total_seconds()
            if time_since_last > 300:  # 5 minutes minimum between major changes
                significant_change = True
                self.last_emotion_change_time = datetime.now()
                self.emotion_change_count = 0
            else:
                # Too frequent - log but don't regenerate
                if random.random() < 0.1:  # Occasional logging
                    print(f"[EMOTION] Frequent emotion changes detected ({prev_emotion}→{curr_emotion}) - stabilizing...")
        
        # Energy/stress level changes (less sensitive)
        if (self.previous_emotion_state['energy_level'] != current_state['energy_level'] or
            self.previous_emotion_state['stress_level'] != current_state['stress_level']):
            # Only trigger if it's been a while since last change
            time_since_last = (datetime.now() - self.last_emotion_change_time).total_seconds()
            if time_since_last > 600:  # 10 minutes for energy/stress changes
                significant_change = True
                self.last_emotion_change_time = datetime.now()
        
        if significant_change:
            print(f"[EMOTION] Significant state change: {prev_emotion}→{curr_emotion}, energy: {self.previous_emotion_state['energy_level']}→{current_state['energy_level']}, stress: {self.previous_emotion_state['stress_level']}→{current_state['stress_level']}")
            self.previous_emotion_state = current_state
            return True
        else:
            # Update state but don't trigger regeneration
            self.previous_emotion_state = current_state
            return False

def trigger_personality_update():
    """Trigger personality-based suggestion regeneration (can be called from other modules)"""
    global bridge_instance
    if bridge_instance:
        print("🎭 Triggering personality-based suggestion regeneration...")
        # Clear old suggestions first
        bridge_instance.clear_old_suggestions()
        # Generate new personality-based suggestions
        bridge_instance._run_avatar_suggestions()
        bridge_instance._run_actionable_suggestions()
        bridge_instance._run_chatter_recipe()
        return True
    else:
        print("❌ Bridge instance not available for personality update")
        return False

# Global bridge instance
bridge_instance = None

def start_observer_bridge():
    """Start the observer-avatar bridge"""
    global bridge_instance
    
    if bridge_instance is None:
        bridge_instance = ObserverAvatarBridge()
        bridge_instance.start_monitoring()
    
    return bridge_instance

def trigger_contextual_message():
    """Trigger a contextual message (can be called from other modules)"""
    global bridge_instance
    if bridge_instance:
        bridge_instance.trigger_contextual_message()

if __name__ == "__main__":
    # Test the bridge
    try:
        from . import avatar_display
    except ImportError:
        # Fallback for direct execution
        import os
        import sys
        sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        from avatar import avatar_display
    
    # Start avatar system
    avatar_display.start_avatar_system()
    time.sleep(2)
    
    # Start bridge
    bridge = start_observer_bridge()
    
    print("🔗 Observer-Avatar bridge test running...")
    print("This will monitor observer files and trigger avatar messages.")
    print("Press Ctrl+C to stop.")
    
    try:
        while True:
            # Occasionally trigger contextual messages for testing
            if random.random() < 0.1:  # 10% chance every loop
                bridge.trigger_contextual_message()
            time.sleep(10)
    except KeyboardInterrupt:
        print("\n👋 Bridge test ended.")
        bridge.stop_monitoring() 