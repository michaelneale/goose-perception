#!/usr/bin/env python3
"""
observer_avatar_bridge.py - Bridge between observer system and avatar display
Monitors observer outputs and triggers appropriate avatar messages
"""

import os
import time
import random
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
import threading

try:
    from . import avatar_display
except ImportError:
    avatar_display = None

class ObserverAvatarBridge:
    def __init__(self):
        self.perception_dir = Path("~/.local/share/goose-perception").expanduser()
        self.last_check_times = {}
        self.last_file_contents = {}
        self.is_running = False
        self.last_suggestions_run = datetime.min
        self.suggestions_interval = timedelta(minutes=10)  # Run avatar suggestions every 10 minutes (more frequent)
        self.last_idle_chatter = datetime.min
        self.idle_chatter_interval = timedelta(minutes=12)  # Show idle chatter every 12 minutes (less frequent)
        self.last_suggestion_show = datetime.min
        self.suggestion_show_interval = timedelta(minutes=15)  # Show existing suggestions every 15 minutes (less frequent)
        
        # Dedicated actionable suggestions timing
        self.last_actionable_show = datetime.min
        self.actionable_show_interval = timedelta(minutes=8)  # Show actionable suggestions every 8 minutes
        self.actionable_suggestions_chance = 0.7  # 70% chance to show actionable suggestions when due
        
        # Ensure perception directory exists
        self.perception_dir.mkdir(parents=True, exist_ok=True)
        
        # Files to monitor
        self.monitored_files = {
            'WORK.md': 'work',
            'LATEST_WORK.md': 'work',
            'INTERACTIONS.md': 'interaction',
            'CONTRIBUTIONS.md': 'productivity',
            'ACTIVITY-LOG.md': 'general',
            'AVATAR_SUGGESTIONS.json': 'suggestions',
            'ACTIONABLE_SUGGESTIONS.json': 'actionable'
        }
        
        # Chit-chat will now be generated by recipe instead of hardcoded
        self.chatter_interval = timedelta(minutes=12)  # Generate new chatter every 12 minutes
        self.last_chatter_run = datetime.now() - self.chatter_interval
        
        # Track shown actionable suggestions to cycle through them
        self.shown_actionable_suggestions = []
        self.max_remembered_actionable = 6  # Remember last 6 shown to avoid immediate repeats
    
    def start_monitoring(self):
        """Start monitoring observer files"""
        if avatar_display is None:
            print("Avatar display not available, bridge disabled")
            return
            
        self.is_running = True
        monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        monitor_thread.start()
        print("üîó Observer-Avatar bridge started...")
    
    def stop_monitoring(self):
        """Stop monitoring"""
        self.is_running = False
    
    def _monitor_loop(self):
        """Main monitoring loop"""
        while self.is_running:
            try:
                self._check_files()
                # Check every 15 seconds for more responsive avatar
                time.sleep(15)
            except Exception as e:
                print(f"Error in observer bridge: {e}")
                time.sleep(60)  # Wait longer on error
    
    def _check_files(self):
        """Check monitored files for changes"""
        current_time = datetime.now()
        
        # Check if it's time to run avatar suggestions (generate new ones)
        if current_time - self.last_suggestions_run > self.suggestions_interval:
            self._run_avatar_suggestions()
            self._run_actionable_suggestions()  # Also check for actionable suggestions
            self.last_suggestions_run = current_time
        
        # Check if it's time to show existing actionable suggestions (higher priority)
        elif current_time - self.last_actionable_show > self.actionable_show_interval:
            self._show_existing_actionable_suggestion()
            self.last_actionable_show = current_time
            
        # Check if it's time to show existing suggestions
        elif current_time - self.last_suggestion_show > self.suggestion_show_interval:
            self._show_existing_suggestion()
            self.last_suggestion_show = current_time
            
        # Check if it's time for idle chatter
        elif current_time - self.last_idle_chatter > self.idle_chatter_interval:
            self._show_idle_chatter()
            self.last_idle_chatter = current_time
            
        # Check if it's time to generate new chit-chat
        elif current_time - self.last_chatter_run > self.chatter_interval:
            self._run_chatter_recipe()
            self.last_chatter_run = current_time
        
        for filename, category in self.monitored_files.items():
            file_path = self.perception_dir / filename
            
            if not file_path.exists():
                continue
                
            try:
                # Get file modification time
                mod_time = datetime.fromtimestamp(file_path.stat().st_mtime)
                last_check = self.last_check_times.get(filename, datetime.min)
                
                # If file was modified since last check
                if mod_time > last_check:
                    self.last_check_times[filename] = current_time
                    
                    # Read new content
                    new_content = file_path.read_text()
                    old_content = self.last_file_contents.get(filename, "")
                    
                    # Check if content actually changed
                    if new_content != old_content:
                        self.last_file_contents[filename] = new_content
                        self._process_file_change(filename, new_content, old_content, category)
                        
            except Exception as e:
                print(f"Error checking {filename}: {e}")
    
    def _run_avatar_suggestions(self):
        """Run the avatar suggestions observer recipe"""
        try:
            print("üîç Running avatar suggestions observer recipe...")
            
            # Get personality parameters
            personality_params = self.get_personality_parameters()
            
            # Build parameter arguments for the recipe
            param_args = []
            for key, value in personality_params.items():
                param_args.extend(['--params', f'{key}={value}'])
            
            # Run the goose recipe with personality parameters
            cmd = [
                "goose", "run", "--no-session", 
                "--recipe", "observers/recipe-avatar-suggestions.yaml"
            ] + param_args
            
            print(f"üé≠ Running with personality: {personality_params['personality_name']}")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if result.returncode == 0:
                print("‚úÖ Avatar suggestions recipe completed successfully")
                self._process_new_suggestions()
            else:
                print(f"‚ùå Avatar suggestions recipe failed: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            print("‚è∞ Avatar suggestions recipe timed out")
        except Exception as e:
            print(f"Error running avatar suggestions: {e}")
    
    def _run_actionable_suggestions(self):
        """Run the actionable suggestions observer recipe"""
        try:
            print("üéØ Running actionable suggestions observer recipe...")
            
            # Get personality parameters
            personality_params = self.get_personality_parameters()
            
            # Build parameter arguments
            param_args = []
            for key, value in personality_params.items():
                param_args.extend(['--params', f'{key}={value}'])
            
            # Run the goose recipe with personality parameters
            cmd = [
                "goose", "run", "--no-session", 
                "--recipe", "observers/recipe-actionable-suggestions.yaml"
            ] + param_args
            
            print(f"üé≠ Running actionable suggestions with personality: {personality_params['personality_name']}")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if result.returncode == 0:
                print("‚úÖ Actionable suggestions recipe completed successfully")
                self._process_actionable_suggestions()
            else:
                print(f"‚ùå Actionable suggestions recipe failed: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            print("‚è∞ Actionable suggestions recipe timed out")
        except Exception as e:
            print(f"Error running actionable suggestions: {e}")
    
    def _run_chatter_recipe(self):
        """Run the chit-chat recipe to generate contextual casual messages"""
        try:
            print("üí¨ Running avatar chit-chat recipe...")
            
            # Get personality parameters
            personality_params = self.get_personality_parameters()
            
            # Build parameter arguments
            param_args = []
            for key, value in personality_params.items():
                param_args.extend(['--params', f'{key}={value}'])
            
            # Run the goose recipe with personality parameters
            cmd = [
                "goose", "run", "--no-session", 
                "--recipe", "observers/recipe-avatar-chatter.yaml"
            ] + param_args
            
            print(f"üé≠ Running chatter with personality: {personality_params['personality_name']}")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                print("‚úÖ Avatar chit-chat recipe completed successfully")
            else:
                print(f"‚ùå Avatar chit-chat recipe failed: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            print("‚è∞ Avatar chit-chat recipe timed out")
        except Exception as e:
            print(f"Error running avatar chit-chat: {e}")
    
    def _parse_suggestions_file(self):
        """Parse the AVATAR_SUGGESTIONS.json file and return suggestions"""
        suggestions_file = self.perception_dir / "AVATAR_SUGGESTIONS.json"
        suggestions = []
        
        if not suggestions_file.exists():
            return suggestions
            
        try:
            import json
            with open(suggestions_file, 'r') as f:
                data = json.load(f)
                raw_suggestions = data.get("suggestions", [])
                
                # Convert to the expected format with type and message
                for suggestion_text in raw_suggestions:
                    suggestions.append({
                        'type': 'general',  # Default type for non-actionable suggestions
                        'message': suggestion_text
                    })
            
            return suggestions
        except Exception as e:
            print(f"Error parsing suggestions file: {e}")
            return []
    
    def _parse_chatter_file(self):
        """Parse the AVATAR_CHATTER.md file and return casual messages"""
        chatter_file = self.perception_dir / "AVATAR_CHATTER.md"
        messages = []
        
        if not chatter_file.exists():
            return messages
            
        try:
            content = chatter_file.read_text()
            lines = content.strip().split('\n')
            
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    messages.append(line)
            
            return messages
        except Exception as e:
            print(f"Error parsing chatter file: {e}")
            return []
    
    def _parse_actionable_suggestions_file(self):
        """Parse the ACTIONABLE_SUGGESTIONS.json file and return actionable suggestions"""
        actionable_file = self.perception_dir / "ACTIONABLE_SUGGESTIONS.json"
        suggestions = []
        
        if not actionable_file.exists():
            return suggestions
            
        try:
            import json
            with open(actionable_file, 'r') as f:
                data = json.load(f)
                raw_suggestions = data.get("actionable_suggestions", [])
            
            # Validate that action commands exist
            from pathlib import Path
            actions_dir = Path("actions")
            available_actions = set()
            if actions_dir.exists():
                available_actions = {f.stem for f in actions_dir.glob("*.yaml")}
            
            # Filter to only valid suggestions
            valid_suggestions = []
            invalid_count = 0
            for suggestion in raw_suggestions:
                action_command = suggestion.get('action_command', '')
                if action_command in available_actions:
                    valid_suggestions.append(suggestion)
                else:
                    invalid_count += 1
                    print(f"‚ö†Ô∏è Skipping actionable suggestion with missing action: {action_command}")
            
            if invalid_count > 0:
                print(f"üìã Filtered {invalid_count} invalid actionable suggestions, {len(valid_suggestions)} valid ones remain")
            
            return valid_suggestions
        except Exception as e:
            print(f"Error parsing actionable suggestions file: {e}")
            return []
    
    def _process_actionable_suggestions(self):
        """Process newly generated actionable suggestions"""
        actionable_suggestions = self._parse_actionable_suggestions_file()
        
        if actionable_suggestions:
            # Pick the most relevant/urgent actionable suggestion
            suggestion = random.choice(actionable_suggestions)
            
            # Show immediately - actionable suggestions are high priority!
            self._show_actionable_suggestion(suggestion)
            print(f"üéØ Immediately showing actionable suggestion: {suggestion['message']}")
    
    def _show_actionable_suggestion(self, suggestion):
        """Show an actionable suggestion with action buttons"""
        try:
            # Create action data for the suggestion
            action_data = {
                'action_type': suggestion['action_type'],
                'action_command': suggestion['action_command'],
                'observation_type': suggestion['observation_type']
            }
            
            # Use the thread-safe function instead of direct avatar_instance call
            from . import avatar_display
            avatar_display.show_actionable_message(
                suggestion['message'], 
                action_data,
                avatar_state='pointing'
            )
            
        except Exception as e:
            print(f"Error showing actionable suggestion: {e}")
    
    def _process_new_suggestions(self):
        """Process newly generated suggestions and show immediately"""
        suggestions = self._parse_suggestions_file()
        
        if not suggestions:
            return
            
        # Show new suggestions immediately - they're fresh and relevant!
        suggestion = random.choice(suggestions)
        self._show_suggestion(suggestion)
        print(f"üí° Immediately showing new suggestion: {suggestion['message']}")
    
    def _show_existing_actionable_suggestion(self):
        """Show an actionable suggestion from the existing pool"""
        actionable_suggestions = self._parse_actionable_suggestions_file()
        
        if not actionable_suggestions:
            print("üì≠ No actionable suggestions available to show")
            return
            
        # Show actionable suggestions with high probability - these are important!
        if random.random() < self.actionable_suggestions_chance:  # 70% chance to show
            # Filter out recently shown suggestions to cycle through them
            fresh_suggestions = [
                s for s in actionable_suggestions 
                if s['action_command'] not in self.shown_actionable_suggestions
            ]
            
            # If we've shown everything recently, reset the tracking
            if not fresh_suggestions:
                fresh_suggestions = actionable_suggestions
                self.shown_actionable_suggestions = []
                print("üîÑ Cycling through actionable suggestions - all have been shown recently")
            
            # Pick a fresh suggestion
            suggestion = random.choice(fresh_suggestions)
            
            # Track this suggestion
            self.shown_actionable_suggestions.append(suggestion['action_command'])
            if len(self.shown_actionable_suggestions) > self.max_remembered_actionable:
                self.shown_actionable_suggestions.pop(0)  # Remove oldest
            
            self._show_actionable_suggestion(suggestion)
            print(f"üéØ Showing actionable suggestion: {suggestion['action_type']} - {suggestion['message'][:60]}...")
        else:
            print("üé≤ Skipped showing actionable suggestion (probability)")
    
    def _show_existing_suggestion(self):
        """Show a suggestion from the existing pool"""
        suggestions = self._parse_suggestions_file()
        
        if not suggestions:
            return
            
        # Show existing suggestions with moderate probability
        if random.random() < 0.4:  # 40% chance to show existing suggestion
            suggestion = random.choice(suggestions)
            self._show_suggestion(suggestion)
    
    def _show_suggestion(self, suggestion):
        """Helper method to show a suggestion with proper avatar state"""
        # Map suggestion types to avatar states
        suggestion_types = {
            'productivity': 'work',
            'collaboration': 'meetings', 
            'focus': 'focus',
            'attention': 'attention',
            'optimization': 'optimization',
            'break': 'break',
            'system': 'optimization'
        }
        
        suggestion_type = suggestion_types.get(suggestion['type'], 'work')
        message = suggestion['message']
        
        # Use the thread-safe function instead of direct call
        from . import avatar_display
        avatar_display.show_suggestion(suggestion_type, message)
    
    def _show_idle_chatter(self):
        """Show casual idle chatter from recipe-generated content"""
        # Show idle chatter with reasonable probability since it's contextual now
        if random.random() < 0.4:  # 40% chance for idle chatter (reduced from 50%)
            chatter_messages = self._parse_chatter_file()
            if chatter_messages:
                # Prefer variety by checking avatar's recent suggestions if possible
                from . import avatar_display
                if (hasattr(avatar_display, 'avatar_instance') and 
                    avatar_display.avatar_instance and
                    hasattr(avatar_display.avatar_instance, 'recent_suggestions')):
                    # Try to avoid messages similar to recent suggestions
                    recent_suggestions = avatar_display.avatar_instance.recent_suggestions
                    filtered_messages = [msg for msg in chatter_messages 
                                       if not any(msg.lower() in recent.lower() or recent.lower() in msg.lower() 
                                               for recent in recent_suggestions[-3:])]  # Check last 3 suggestions
                    if filtered_messages:
                        message = random.choice(filtered_messages)
                    else:
                        message = random.choice(chatter_messages)
                else:
                    message = random.choice(chatter_messages)
                
                # Use the thread-safe function instead of direct call
                avatar_display.show_message(message, 4000)
                print(f"üí¨ Showed casual chatter: {message[:50]}...")
    
    def _process_file_change(self, filename, new_content, old_content, category):
        """Process a file change and potentially trigger avatar message"""
        try:
            # Handle avatar suggestions file updates
            if filename == 'AVATAR_SUGGESTIONS.json':
                self._process_new_suggestions()
                return
            
            # For other files, occasionally show a contextual message
            if random.random() > 0.3:  # 30% chance to show message
                return
                
            # Simple fallback messages for file changes - use thread-safe functions
            from . import avatar_display
            if filename == 'LATEST_WORK.md':
                avatar_display.show_message("üìù I see you're updating your current work focus...")
            elif filename == 'INTERACTIONS.md':
                avatar_display.show_message("ü§ù New interaction data updated...")
            elif filename == 'CONTRIBUTIONS.md':
                avatar_display.show_message("üìà Your contribution patterns have been updated...")
                
        except Exception as e:
            print(f"Error processing {filename} change: {e}")
    
    def get_personality_parameters(self):
        """Get personality parameters for recipes"""
        try:
            # Try to get personality from avatar instance
            from . import avatar_display
            if (hasattr(avatar_display, 'avatar_instance') and 
                avatar_display.avatar_instance and
                hasattr(avatar_display.avatar_instance, 'get_current_personality_data')):
                
                personality_key = avatar_display.avatar_instance.current_personality
                personality_data = avatar_display.avatar_instance.get_current_personality_data()
                
                if personality_data:
                    return {
                        'personality_name': personality_data.get('name', personality_key.title()),
                        'personality_style': personality_data.get('suggestion_style', ''),
                        'personality_tone': personality_data.get('tone', ''),
                        'personality_priorities': ', '.join(personality_data.get('priorities', [])),
                        'personality_phrases': ', '.join(personality_data.get('example_phrases', []))
                    }
            
            # Fallback to comedian personality
            return {
                'personality_name': 'Comedian',
                'personality_style': 'Everything is an opportunity for humor. Makes jokes about coding, work situations, and daily activities. Keeps things light and funny.',
                'personality_tone': 'humorous, witty, entertaining, lighthearted',
                'personality_priorities': 'humor, entertainment, making people laugh, finding the funny side',
                'personality_phrases': 'Why did the developer, Speaking of comedy, Here\'s a joke for you, Plot twist comedy, Funny thing about'
            }
        except Exception as e:
            print(f"Error getting personality parameters: {e}")
            # Return default parameters
            return {
                'personality_name': 'Comedian',
                'personality_style': 'Everything is an opportunity for humor. Makes jokes about coding, work situations, and daily activities.',
                'personality_tone': 'humorous, witty, entertaining',
                'personality_priorities': 'humor, entertainment, making people laugh',
                'personality_phrases': 'Why did the developer, Speaking of comedy, Here\'s a joke for you'
            }

    def trigger_contextual_message(self):
        """Trigger a contextual message from recipes"""
        if avatar_display is None:
            return
        
        # Try to show a chit-chat message from recipe-generated content
        chatter_messages = self._parse_chatter_file()
        if chatter_messages:
            message = random.choice(chatter_messages)
            avatar_display.show_message(message, 4000)
        else:
            # Fallback to simple interaction if no chatter available
            avatar_display.show_message("üëã How's it going?", 3000)

    def clear_old_suggestions(self):
        """Clear old suggestion files to ensure only personality-appropriate content remains"""
        try:
            suggestion_files = [
                self.perception_dir / "AVATAR_SUGGESTIONS.json",
                self.perception_dir / "ACTIONABLE_SUGGESTIONS.json", 
                self.perception_dir / "AVATAR_CHATTER.md"
            ]
            
            for file_path in suggestion_files:
                if file_path.exists():
                    file_path.unlink()
                    print(f"üóëÔ∏è Cleared old suggestions from {file_path.name}")
                    
        except Exception as e:
            print(f"‚ö†Ô∏è Error clearing old suggestions: {e}")

def trigger_personality_update():
    """Trigger personality-based suggestion regeneration (can be called from other modules)"""
    global bridge_instance
    if bridge_instance:
        print("üé≠ Triggering personality-based suggestion regeneration...")
        # Clear old suggestions first
        bridge_instance.clear_old_suggestions()
        # Generate new personality-based suggestions
        bridge_instance._run_avatar_suggestions()
        bridge_instance._run_actionable_suggestions()
        bridge_instance._run_chatter_recipe()
        return True
    else:
        print("‚ùå Bridge instance not available for personality update")
        return False

# Global bridge instance
bridge_instance = None

def start_observer_bridge():
    """Start the observer-avatar bridge"""
    global bridge_instance
    
    if bridge_instance is None:
        bridge_instance = ObserverAvatarBridge()
        bridge_instance.start_monitoring()
    
    return bridge_instance

def trigger_contextual_message():
    """Trigger a contextual message (can be called from other modules)"""
    global bridge_instance
    if bridge_instance:
        bridge_instance.trigger_contextual_message()

if __name__ == "__main__":
    # Test the bridge
    try:
        from . import avatar_display
    except ImportError:
        # Fallback for direct execution
        import os
        import sys
        sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        from avatar import avatar_display
    
    # Start avatar system
    avatar_display.start_avatar_system()
    time.sleep(2)
    
    # Start bridge
    bridge = start_observer_bridge()
    
    print("üîó Observer-Avatar bridge test running...")
    print("This will monitor observer files and trigger avatar messages.")
    print("Press Ctrl+C to stop.")
    
    try:
        while True:
            # Occasionally trigger contextual messages for testing
            if random.random() < 0.1:  # 10% chance every loop
                bridge.trigger_contextual_message()
            time.sleep(10)
    except KeyboardInterrupt:
        print("\nüëã Bridge test ended.")
        bridge.stop_monitoring() 